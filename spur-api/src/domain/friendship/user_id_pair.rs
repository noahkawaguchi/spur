use super::error::FriendshipError;
use std::cmp::Ordering::{Equal, Greater, Less};

/// A pair of user IDs that are guaranteed to be distinct.
#[cfg_attr(test, derive(Debug, PartialEq, Eq, Clone))]
pub struct UserIdPair(i32, i32);

impl UserIdPair {
    /// Creates a structured pair of user IDs, which can be provided in either order. Returns Err
    /// if the two IDs are the same.
    pub fn new(id_a: i32, id_b: i32) -> Result<Self, FriendshipError> {
        match id_a.cmp(&id_b) {
            Less => Ok(Self(id_a, id_b)),
            Greater => Ok(Self(id_b, id_a)),
            Equal => Err(FriendshipError::SelfFriendship),
        }
    }

    /// Gets the user ID of strictly lesser numeric value.
    pub const fn lesser(&self) -> i32 { self.0 }

    /// Gets the user ID of strictly greater numeric value.
    pub const fn greater(&self) -> i32 { self.1 }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Not testing for negative/zero user IDs because user IDs are generated by Postgres and only
    // used internally.

    #[test]
    fn reorders_ids() {
        let ids = UserIdPair::new(52, 14).expect("failed to create pair for distinct IDs");
        assert_eq!(ids.lesser(), 14);
        assert_eq!(ids.greater(), 52);
    }

    #[test]
    fn keeps_already_ordered_ids() {
        let ids = UserIdPair::new(4, 100).expect("failed to create pair for distinct IDs");
        assert_eq!(ids.lesser(), 4);
        assert_eq!(ids.greater(), 100);
    }

    #[test]
    fn rejects_equal_ids() {
        let result = UserIdPair::new(512, 512);
        assert!(matches!(result, Err(FriendshipError::SelfFriendship)));
    }
}
