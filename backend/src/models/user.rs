use chrono::{DateTime, Utc};

/// User with plaintext password and without DB-generated fields. Same fields as `SignupRequest`.
#[cfg_attr(test, derive(Debug, Clone, PartialEq, Eq))]
pub struct UserRegistration {
    pub name: String,
    pub email: String,
    pub username: String,
    pub password: String,
}

impl UserRegistration {
    pub fn into_new_user_with_hash(self, password_hash: String) -> NewUser {
        NewUser { name: self.name, email: self.email, username: self.username, password_hash }
    }
}

/// User with hashed password but without the fields generated by the database.
#[cfg_attr(test, derive(Debug, Clone, PartialEq, Eq))]
pub struct NewUser {
    pub name: String,
    pub email: String,
    pub username: String,
    pub password_hash: String,
}

/// Full user struct as represented in the database.
#[cfg_attr(test, derive(Debug, Clone, PartialEq, Eq))]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub username: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
}

#[cfg(test)]
mod user_test_impl {
    use super::*;

    impl PartialEq<&NewUser> for User {
        fn eq(&self, other: &&NewUser) -> bool {
            self.name == other.name
                && self.email == other.email
                && self.username == other.username
                && self.password_hash == other.password_hash
        }
    }

    impl From<User> for NewUser {
        fn from(user: User) -> Self {
            Self {
                name: user.name,
                email: user.email,
                username: user.username,
                password_hash: user.password_hash,
            }
        }
    }
}
